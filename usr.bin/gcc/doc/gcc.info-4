Info file gcc.info, produced by Makeinfo, -*- Text -*- from input
file gcc.texinfo.

This file documents the use and the internals of the GNU compiler.

Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License" and "Protect
Your Freedom--Fight `Look And Feel'" are included exactly as in the
original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License" and "Protect Your Freedom--Fight `Look And Feel'" and this
permission notice may be included in translations approved by the
Free Software Foundation instead of in the original English.



File: gcc.info,  Node: Zero-Length,  Next: Variable-Length,  Prev: Conditionals,  Up: Extensions

Arrays of Length Zero
=====================

Zero-length arrays are allowed in GNU C.  They are very useful as the
last element of a structure which is really a header for a
variable-length object:

     struct line {
       int length;
       char contents[0];
     };
     
     {
       struct line *thisline 
         = (struct line *) malloc (sizeof (struct line) + this_length);
       thisline->length = this_length;
     }

In standard C, you would have to give `contents' a length of 1, which
means either you waste space or complicate the argument to `malloc'.



File: gcc.info,  Node: Variable-Length,  Next: Subscripting,  Prev: Zero-Length,  Up: Extensions

Arrays of Variable Length
=========================

Variable-length automatic arrays are allowed in GNU C.  These arrays
are declared like any other automatic arrays, but with a length that
is not a constant expression.  The storage is allocated at that time
and deallocated when the brace-level is exited.  For example:

     FILE *concat_fopen (char *s1, char *s2, char *mode)
     {
       char str[strlen (s1) + strlen (s2) + 1];
       strcpy (str, s1);
       strcat (str, s2);
       return fopen (str, mode);
     }

You can also use variable-length arrays as arguments to functions:

     struct entry
     tester (int len, char data[len])
     {
       ...
     }

The length of an array is computed on entry to the brace-level where
the array is declared and is remembered for the scope of the array in
case you access it with `sizeof'.

Jumping or breaking out of the scope of the array name will also
deallocate the storage.  Jumping into the scope is not allowed; you
will get an error message for it.

You can use the function `alloca' to get an effect much like
variable-length arrays.  The function `alloca' is available in many
other C implementations (but not in all).  On the other hand,
variable-length arrays are more elegant.

There are other differences between these two methods.  Space
allocated with `alloca' exists until the containing *function* returns.
The space for a variable-length array is deallocated as soon as the
array name's scope ends.  (If you use both variable-length arrays and
`alloca' in the same function, deallocation of a variable-length
array will also deallocate anything more recently allocated with
`alloca'.)



File: gcc.info,  Node: Subscripting,  Next: Pointer Arith,  Prev: Variable-Length,  Up: Extensions

Non-Lvalue Arrays May Have Subscripts
=====================================

Subscripting is allowed on arrays that are not lvalues, even though
the unary `&' operator is not.  For example, this is valid in GNU C
though not valid in other C dialects:

     struct foo {int a[4];};
     
     struct foo f();
     
     bar (int index)
     {
       return f().a[index];
     }



File: gcc.info,  Node: Pointer Arith,  Next: Initializers,  Prev: Subscripting,  Up: Extensions

Arithmetic on `void'-Pointers and Function Pointers
===================================================

In GNU C, addition and subtraction operations are supported on
pointers to `void' and on pointers to functions.  This is done by
treating the size of a `void' or of a function as 1.

A consequence of this is that `sizeof' is also allowed on `void' and
on function types, and returns 1.

The option `-Wpointer-arith' requests a warning if these extensions
are used.



File: gcc.info,  Node: Initializers,  Next: Constructors,  Prev: Pointer Arith,  Up: Extensions

Non-Constant Initializers
=========================

The elements of an aggregate initializer for an automatic variable
are not required to be constant expressions in GNU C.  Here is an
example of an initializer with run-time varying elements:

     foo (float f, float g)
     {
       float beat_freqs[2] = { f-g, f+g };
       ...
     }



File: gcc.info,  Node: Constructors,  Next: Function Attributes,  Prev: Initializers,  Up: Extensions

Constructor Expressions
=======================

GNU C supports constructor expressions.  A constructor looks like a
cast containing an initializer.  Its value is an object of the type
specified in the cast, containing the elements specified in the
initializer.  The type must be a structure, union or array type.

Assume that `struct foo' and `structure' are declared as shown:

     struct foo {int a; char b[2];} structure;

Here is an example of constructing a `struct foo' with a constructor:

     structure = ((struct foo) {x + y, 'a', 0});

This is equivalent to writing the following:

     {
       struct foo temp = {x + y, 'a', 0};
       structure = temp;
     }

You can also construct an array.  If all the elements of the
constructor are (made up of) simple constant expressions, suitable
for use in initializers, then the constructor is an lvalue and can be
coerced to a pointer to its first element, as shown here:

     char **foo = (char *[]) { "x", "y", "z" };

Array constructors whose elements are not simple constants are not
very useful, because the constructor is not an lvalue.  There are
only two valid ways to use it: to subscript it, or initialize an
array variable with it.  The former is probably slower than a
`switch' statement, while the latter does the same thing an ordinary
C initializer would do.

     output = ((int[]) { 2, x, 28 }) [input];



File: gcc.info,  Node: Function Attributes,  Next: Dollar Signs,  Prev: Constructors,  Up: Extensions

Declaring Attributes of Functions
=================================

In GNU C, you declare certain things about functions called in your
program which help the compiler optimize function calls.

A few functions, such as `abort' and `exit', cannot return.  These
functions should be declared `volatile'.  For example,

     extern volatile void abort ();

tells the compiler that it can assume that `abort' will not return. 
This makes slightly better code, but more importantly it helps avoid
spurious warnings of uninitialized variables.

Many functions do not examine any values except their arguments, and
have no effects except the return value.  Such a function can be
subject to common subexpression elimination and loop optimization
just as an arithmetic operator would be.  These functions should be
declared `const'.  For example,

     extern const void square ();

says that the hypothetical function `square' is safe to call fewer
times than the program says.

Note that a function that has pointer arguments and examines the data
pointed to must *not* be declared `const'.  Likewise, a function that
calls a non-`const' function usually must not be `const'.

Some people object to this feature, claiming that ANSI C's `#pragma'
should be used instead.  There are two reasons I did not do this.

  1. It is impossible to generate `#pragma' commands from a macro.

  2. The `#pragma' command is just as likely as these keywords to
     mean something else in another compiler.

These two reasons apply to *any* application whatever: as far as I
can see, `#pragma' is never useful.



File: gcc.info,  Node: Dollar Signs,  Next: Alignment,  Prev: Function Attributes,  Up: Extensions

Dollar Signs in Identifier Names
================================

In GNU C, you may use dollar signs in identifier names.  This is
because many traditional C implementations allow such identifiers.

Dollar signs are allowed if you specify `-traditional'; they are not
allowed if you specify `-ansi'.  Whether they are allowed by default
depends on the target machine; usually, they are not.



File: gcc.info,  Node: Alignment,  Next: Inline,  Prev: Dollar Signs,  Up: Extensions

Inquiring about the Alignment of a Type or Variable
===================================================

The keyword `__alignof__' allows you to inquire about how an object
is aligned, or the minimum alignment usually required by a type.  Its
syntax is just like `sizeof'.

For example, if the target machine requires a `double' value to be
aligned on an 8-byte boundary, then `__alignof__ (double)' is 8. 
This is true on many RISC machines.  On more traditional machine
designs, `__alignof__ (double)' is 4 or even 2.

Some machines never actually require alignment; they allow reference
to any data type even at an odd addresses.  For these machines,
`__alignof__' reports the *recommended* alignment of a type.

When the operand of `__alignof__' is an lvalue rather than a type,
the value is the largest alignment that the lvalue is known to have. 
It may have this alignment as a result of its data type, or because
it is part of a structure and inherits alignment from that structure.
For example, after this declaration:

     struct foo { int x; char y; } foo1;

the value of `__alignof__ (foo1.y)' is probably 2 or 4, the same as
`__alignof__ (int)', even though the data type of `foo1.y' does not
itself demand any alignment.



File: gcc.info,  Node: Inline,  Next: Extended Asm,  Prev: Alignment,  Up: Extensions

An Inline Function is As Fast As a Macro
========================================

By declaring a function `inline', you can direct GNU CC to integrate
that function's code into the code for its callers.  This makes
execution faster by eliminating the function-call overhead; in
addition, if any of the actual argument values are constant, their
known values may permit simplifications at compile time so that not
all of the inline function's code needs to be included.

To declare a function inline, use the `inline' keyword in its
declaration, like this:

     inline int
     inc (int *a)
     {
       (*a)++;
     }

(If you are writing a header file to be included in ANSI C programs,
write `__inline__' instead of `inline'.  *Note Alternate Keywords::.)

You can also make all "simple enough" functions inline with the
option `-finline-functions'.  Note that certain usages in a function
definition can make it unsuitable for inline substitution.

When a function is both inline and `static', if all calls to the
function are integrated into the caller, and the function's address
is never used, then the function's own assembler code is never
referenced.  In this case, GNU CC does not actually output assembler
code for the function, unless you specify the option
`-fkeep-inline-functions'.  Some calls cannot be integrated for
various reasons (in particular, calls that precede the function's
definition cannot be integrated, and neither can recursive calls
within the definition).  If there is a nonintegrated call, then the
function is compiled to assembler code as usual.  The function must
also be compiled as usual if the program refers to its address,
because that can't be inlined.

When an inline function is not `static', then the compiler must
assume that there may be calls from other source files; since a
global symbol can be defined only once in any program, the function
must not be defined in the other source files, so the calls therein
cannot be integrated.  Therefore, a non-`static' inline function is
always compiled on its own in the usual fashion.

If you specify both `inline' and `extern' in the function definition,
then the definition is used only for inlining.  In no case is the
function compiled on its own, not even if you refer to its address
explicitly.  Such an address becomes an external reference, as if you
had only declared the function, and had not defined it.

This combination of `inline' and `extern' has almost the effect of a
macro.  The way to use it is to put a function definition in a header
file with these keywords, and put another copy of the definition
(lacking `inline' and `extern') in a library file.  The definition in
the header file will cause most calls to the function to be inlined. 
If any uses of the function remain, they will refer to the single
copy in the library.



File: gcc.info,  Node: Extended Asm,  Next: Asm Labels,  Prev: Inline,  Up: Extensions

Assembler Instructions with C Expression Operands
=================================================

In an assembler instruction using `asm', you can now specify the
operands of the instruction using C expressions.  This means no more
guessing which registers or memory locations will contain the data
you want to use.

You must specify an assembler instruction template much like what
appears in a machine description, plus an operand constraint string
for each operand.

For example, here is how to use the 68881's `fsinx' instruction:

     asm ("fsinx %1,%0" : "=f" (result) : "f" (angle));

Here `angle' is the C expression for the input operand while `result'
is that of the output operand.  Each has `"f"' as its operand
constraint, saying that a floating-point register is required.  The
`=' in `=f' indicates that the operand is an output; all output
operands' constraints must use `='.  The constraints use the same
language used in the machine description (*note Constraints::.).

Each operand is described by an operand-constraint string followed by
the C expression in parentheses.  A colon separates the assembler
template from the first output operand, and another separates the
last output operand from the first input, if any.  Commas separate
output operands and separate inputs.  The total number of operands is
limited to the maximum number of operands in any instruction pattern
in the machine description.

If there are no output operands, and there are input operands, then
there must be two consecutive colons surrounding the place where the
output operands would go.

Output operand expressions must be lvalues; the compiler can check
this.  The input operands need not be lvalues.  The compiler cannot
check whether the operands have data types that are reasonable for
the instruction being executed.  It does not parse the assembler
instruction template and does not know what it means, or whether it
is valid assembler input.  The extended `asm' feature is most often
used for machine instructions that the compiler itself does not know
exist.

The output operands must be write-only; GNU CC will assume that the
values in these operands before the instruction are dead and need not
be generated.  Extended asm does not support input-output or
read-write operands.  For this reason, the constraint character `+',
which indicates such an operand, may not be used.

When the assembler instruction has a read-write operand, or an
operand in which only some of the bits are to be changed, you must
logically split its function into two separate operands, one input
operand and one write-only output operand.  The connection between
them is expressed by constraints which say they need to be in the
same location when the instruction executes.  You can use the same C
expression for both operands, or different expressions.  For example,
here we write the (fictitious) `combine' instruction with `bar' as
its read-only source operand and `foo' as its read-write destination:

     asm ("combine %2,%0" : "=r" (foo) : "0" (foo), "g" (bar));

The constraint `"0"' for operand 1 says that it must occupy the same
location as operand 0.  A digit in constraint is allowed only in an
input operand, and it must refer to an output operand.

Only a digit in the constraint can guarantee that one operand will be
in the same place as another.  The mere fact that `foo' is the value
of both operands is not enough to guarantee that they will be in the
same place in the generated assembler code.  The following would not
work:

     asm ("combine %2,%0" : "=r" (foo) : "r" (foo), "g" (bar));

Various optimizations or reloading could cause operands 0 and 1 to be
in different registers; GNU CC knows no reason not to do so.  For
example, the compiler might find a copy of the value of `foo' in one
register and use it for operand 1, but generate the output operand 0
in a different register (copying it afterward to `foo''s own
address).  Of course, since the register for operand 1 is not even
mentioned in the assembler code, the result will not work, but GNU CC
can't tell that.

Unless an output operand has the `&' constraint modifier, GNU CC may
allocate it in the same register as an unrelated input operand, on
the assumption that the inputs are consumed before the outputs are
produced.  This assumption may be false if the assembler code
actually consists of more than one instruction.  In such a case, use
`&' for each output operand that may not overlap an input.  *Note
Modifiers::.

Some instructions clobber specific hard registers.  To describe this,
write a third colon after the input operands, followed by the names
of the clobbered hard registers (given as strings).  Here is a
realistic example for the vax:

     asm volatile ("movc3 %0,%1,%2"
                   : /* no outputs */
                   : "g" (from), "g" (to), "g" (count)
                   : "r0", "r1", "r2", "r3", "r4", "r5");

You can put multiple assembler instructions together in a single
`asm' template, separated either with newlines (written as `\n') or
with semicolons if the assembler allows such semicolons.  The GNU
assembler allows semicolons and all Unix assemblers seem to do so. 
The input operands are guaranteed not to use any of the clobbered
registers, and neither will the output operands' addresses, so you
can read and write the clobbered registers as many times as you like.
Here is an example of multiple instructions in a template; it assumes
that the subroutine `_foo' accepts arguments in registers 9 and 10:

     asm ("movl %0,r9;movl %1,r10;call _foo"
          : /* no outputs */
          : "g" (from), "g" (to)
          : "r9", "r10");

If you want to test the condition code produced by an assembler
instruction, you must include a branch and a label in the `asm'
construct, as follows:

     asm ("clr %0;frob %1;beq 0f;mov #1,%0;0:"
          : "g" (result)
          : "g" (input));

This assumes your assembler supports local labels, as the GNU
assembler and most Unix assemblers do.

Usually the most convenient way to use these `asm' instructions is to
encapsulate them in macros that look like functions.  For example,

     #define sin(x)       \
     ({ double __value, __arg = (x);   \
        asm ("fsinx %1,%0": "=f" (__value): "f" (__arg));  \
        __value; })

Here the variable `__arg' is used to make sure that the instruction
operates on a proper `double' value, and to accept only those
arguments `x' which can convert automatically to a `double'.

Another way to make sure the instruction operates on the correct data
type is to use a cast in the `asm'.  This is different from using a
variable `__arg' in that it converts more different types.  For
example, if the desired type were `int', casting the argument to
`int' would accept a pointer with no complaint, while assigning the
argument to an `int' variable named `__arg' would warn about using a
pointer unless the caller explicitly casts it.

If an `asm' has output operands, GNU CC assumes for optimization
purposes that the instruction has no side effects except to change
the output operands.  This does not mean that instructions with a
side effect cannot be used, but you must be careful, because the
compiler may eliminate them if the output operands aren't used, or
move them out of loops, or replace two with one if they constitute a
common subexpression.  Also, if your instruction does have a side
effect on a variable that otherwise appears not to change, the old
value of the variable may be reused later if it happens to be found
in a register.

You can prevent an `asm' instruction from being deleted, moved or
combined by writing the keyword `volatile' after the `asm'.  For
example:

     #define set_priority(x)  \
     asm volatile ("set_priority %0": /* no outputs */ : "g" (x))

(However, an instruction without output operands will not be deleted
or moved, regardless, unless it is unreachable.)

It is a natural idea to look for a way to give access to the
condition code left by the assembler instruction.  However, when we
attempted to implement this, we found no way to make it work
reliably.  The problem is that output operands might need reloading,
which would result in additional following "store" instructions.  On
most machines, these instructions would alter the condition code
before there was time to test it.  This problem doesn't arise for
ordinary "test" and "compare" instructions because they don't have
any output operands.

If you are writing a header file that should be includable in ANSI C
programs, write `__asm__' instead of `asm'.  *Note Alternate
Keywords::.



File: gcc.info,  Node: Asm Labels,  Next: Explicit Reg Vars,  Prev: Extended Asm,  Up: Extensions

Controlling Names Used in Assembler Code
========================================

You can specify the name to be used in the assembler code for a C
function or variable by writing the `asm' (or `__asm__') keyword
after the declarator as follows:

     int foo asm ("myfoo") = 2;

This specifies that the name to be used for the variable `foo' in the
assembler code should be `myfoo' rather than the usual `_foo'.

On systems where an underscore is normally prepended to the name of a
C function or variable, this feature allows you to define names for
the linker that do not start with an underscore.

You cannot use `asm' in this way in a function *definition*; but you
can get the same effect by writing a declaration for the function
before its definition and putting `asm' there, like this:

     extern func () asm ("FUNC");
     
     func (x, y)
          int x, y;
     ...

 It is up to you to make sure that the assembler names you choose do
not conflict with any other assembler symbols.  Also, you must not
use a register name; that would produce completely invalid assembler
code.  GNU CC does not as yet have the ability to store static
variables in registers.  Perhaps that will be added.



File: gcc.info,  Node: Explicit Reg Vars,  Next: Alternate Keywords,  Prev: Asm Labels,  Up: Extensions

Variables in Specified Registers
================================

GNU C allows you to put a few global variables into specified
hardware registers.  You can also specify the register in which an
ordinary register variable should be allocated.

   * Global register variables reserve registers throughout the
     program.  This may be useful in programs such as programming
     language interpreters which have a couple of global variables
     that are accessed very often.

   * Local register variables in specific registers do not reserve
     the registers.  The compiler's data flow analysis is capable of
     determining where the specified registers contain live values,
     and where they are available for other uses.  These local
     variables are sometimes convenient for use with the extended
     `asm' feature (*note Extended Asm::.).

* Menu:

* Global Reg Vars::
* Local Reg Vars::



File: gcc.info,  Node: Global Reg Vars,  Next: Local Reg Vars,  Prev: Explicit Reg Vars,  Up: Explicit Reg Vars

Defining Global Register Variables
----------------------------------

You can define a global register variable in GNU C like this:

     register int *foo asm ("a5");

Here `a5' is the name of the register which should be used.  Choose a
register which is normally saved and restored by function calls on
your machine, so that library routines will not clobber it.

Naturally the register name is cpu-dependent, so you would need to
conditionalize your program according to cpu type.  The register `a5'
would be a good choice on a 68000 for a variable of pointer type.  On
machines with register windows, be sure to choose a "global" register
that is not affected magically by the function call mechanism.

In addition, operating systems on one type of cpu may differ in how
they name the registers; then you would need additional conditionals.
For example, some 68000 operating systems call this register `%a5'.

Eventually there may be a way of asking the compiler to choose a
register automatically, but first we need to figure out how it should
choose and how to enable you to guide the choice.  No solution is
evident.

Defining a global register variable in a certain register reserves
that register entirely for this use, at least within the current
compilation.  The register will not be allocated for any other
purpose in the functions in the current compilation.  The register
will not be saved and restored by these functions.  Stores into this
register are never deleted even if they would appear to be dead, but
references may be deleted or moved or simplified.

It is not safe to access the global register variables from signal
handlers, or from more than one thread of control, because the system
library routines may temporarily use the register for other things
(unless you recompile them specially for the task at hand).

It is not safe for one function that uses a global register variable
to call another such function `foo' by way of a third function `lose'
that was compiled without knowledge of this variable (i.e. in a
different source file in which the variable wasn't declared).  This
is because `lose' might save the register and put some other value
there.  For example, you can't expect a global register variable to
be available in the comparison-function that you pass to `qsort',
since `qsort' might have put something else in that register.  (If
you are prepared to recompile `qsort' with the same global register
variable, you can solve this problem.)

If you want to recompile `qsort' or other source files which do not
actually use your global register variable, so that they will not use
that register for any other purpose, then it suffices to specify the
compiler option `-ffixed-REG'.  You need not actually add a global
register declaration to their source code.

A function which can alter the value of a global register variable
cannot safely be called from a function compiled without this
variable, because it could clobber the value the caller expects to
find there on return.  Therefore, the function which is the entry
point into the part of the program that uses the global register
variable must explicitly save and restore the value which belongs to
its caller.

On most machines, `longjmp' will restore to each global register
variable the value it had at the time of the `setjmp'.  On some
machines, however, `longjmp' will not change the value of global
register variables.  To be portable, the function that called
`setjmp' should make other arrangements to save the values of the
global register variables, and to restore them in a `longjmp'.  This
way, the same thing will happen regardless of what `longjmp' does.

All global register variable declarations must precede all function
definitions.  If such a declaration could appear after function
definitions, the declaration would be too late to prevent the
register from being used for other purposes in the preceding functions.

Global register variables may not have initial values, because an
executable file has no means to supply initial contents for a register.



File: gcc.info,  Node: Local Reg Vars,  Prev: Global Reg Vars,  Up: Explicit Reg Vars

Specifying Registers for Local Variables
----------------------------------------

You can define a local register variable with a specified register
like this:

     register int *foo asm ("a5");

Here `a5' is the name of the register which should be used.  Note
that this is the same syntax used for defining global register
variables, but for a local variable it would appear within a function.

Naturally the register name is cpu-dependent, but this is not a
problem, since specific registers are most often useful with explicit
assembler instructions (*note Extended Asm::.).  Both of these things
generally require that you conditionalize your program according to
cpu type.

In addition, operating systems on one type of cpu may differ in how
they name the registers; then you would need additional conditionals.
For example, some 68000 operating systems call this register `%a5'.

Eventually there may be a way of asking the compiler to choose a
register automatically, but first we need to figure out how it should
choose and how to enable you to guide the choice.  No solution is
evident.

Defining such a register variable does not reserve the register; it
remains available for other uses in places where flow control
determines the variable's value is not live.  However, these
registers are made unavailable for use in the reload pass.  I would
not be surprised if excessive use of this feature leaves the compiler
too few available registers to compile certain functions.



File: gcc.info,  Node: Alternate Keywords,  Prev: Explicit Reg Vars,  Up: Extensions

Alternate Keywords
==================

The option `-traditional' disables certain keywords; `-ansi' disables
certain others.  This causes trouble when you want to use GNU C
extensions, or ANSI C features, in a general-purpose header file that
should be usable by all programs, including ANSI C programs and
traditional ones.  The keywords `asm', `typeof' and `inline' cannot
be used since they won't work in a program compiled with `-ansi',
while the keywords `const', `volatile', `signed', `typeof' and
`inline' won't work in a program compiled with `-traditional'.

The way to solve these problems is to put `__' at the beginning and
end of each problematical keyword.  For example, use `__asm__'
instead of `asm', `__const__' instead of `const', and `__inline__'
instead of `inline'.

Other C compilers won't accept these alternative keywords; if you
want to compile with another compiler, you can define the alternate
keywords as macros to replace them with the customary keywords.  It
looks like this:

     #ifndef __GNUC__
     #define __asm__ asm
     #endif



File: gcc.info,  Node: Bugs,  Next: Portability,  Prev: Extensions,  Up: Top

Reporting Bugs
**************

Your bug reports play an essential role in making GNU CC reliable.

When you encounter a problem, the first thing to do is to see if it
is already known.  *Note Trouble::.  Also look in *Note
Incompatibilities::.  If it isn't known, then you should report the
problem.

Reporting a bug may help you by bringing a solution to your problem,
or it may not.  (If it does not, look in the service directory; see
*Note Service::.)  In any case, the principal function of a bug
report is to help the entire community by making the next version of
GNU CC work better.  Bug reports are your contribution to the
maintenance of GNU CC.

In order for a bug report to serve its purpose, you must include the
information that makes for fixing the bug.

* Menu:

* Criteria:  Bug Criteria.   Have you really found a bug?
* Reporting: Bug Reporting.  How to report a bug effectively.

 

File: gcc.info,  Node: Bug Criteria,  Next: Bug Reporting,  Prev: Bugs,  Up: Bugs

Have You Found a Bug?
=====================

If you are not sure whether you have found a bug, here are some
guidelines:

   * If the compiler gets a fatal signal, for any input whatever,
     that is a compiler bug.  Reliable compilers never crash.

   * If the compiler produces invalid assembly code, for any input
     whatever (except an `asm' statement), that is a compiler bug,
     unless the compiler reports errors (not just warnings) which
     would ordinarily prevent the assembler from being run.

   * If the compiler produces valid assembly code that does not
     correctly execute the input source code, that is a compiler bug.

     However, you must double-check to make sure, because you may
     have run into an incompatibility between GNU C and traditional C
     (*note Incompatibilities::.).  These incompatibilities might be
     considered bugs, but they are inescapable consequences of
     valuable features.

     Or you may have a program whose behavior is undefined, which
     happened by chance to give the desired results with another C
     compiler.

     For example, in many nonoptimizing compilers, you can write `x;'
     at the end of a function instead of `return x;', with the same
     results.  But the value of the function is undefined if `return'
     is omitted; it is not a bug when GNU CC produces different
     results.

     Problems often result from expressions with two increment
     operators, as in `f (*p++, *p++)'.  Your previous compiler might
     have interpreted that expression the way you intended; GNU CC
     might interpret it another way.  Neither compiler is wrong.  The
     bug is in your code.

     After you have localized the error to a single source line, it
     should be easy to check for these things.  If your program is
     correct and well defined, you have found a compiler bug.

   * If the compiler produces an error message for valid input, that
     is a compiler bug.

     Note that the following is not valid input, and the error
     message for it is not a bug:

          int foo (char);
          
          int
          foo (x)
               char x;
          { ... }

     The prototype says to pass a `char', while the definition says
     to pass an `int' and treat the value as a `char'.  This is what
     the ANSI standard says, and it makes sense.

   * If the compiler does not produce an error message for invalid
     input, that is a compiler bug.  However, you should note that
     your idea of "invalid input" might be my idea of "an extension"
     or "support for traditional practice".

   * If you are an experienced user of C compilers, your suggestions
     for improvement of GNU CC are welcome in any case.



File: gcc.info,  Node: Bug Reporting,  Prev: Bug Criteria,  Up: Bugs

How to Report Bugs
==================

Send bug reports for GNU C to one of these addresses:

     bug-gcc@prep.ai.mit.edu
     {ucbvax|mit-eddie|uunet}!prep.ai.mit.edu!bug-gcc

*Do not send bug reports to `info-gcc', or to the newsgroup
`gnu.gcc'.* Most users of GNU CC do not want to receive bug reports. 
Those that do, have asked to be on `bug-gcc'.

The mailing list `bug-gcc' has a newsgroup which serves as a
repeater.  The mailing list and the newsgroup carry exactly the same
messages.  Often people think of posting bug reports to the newsgroup
instead of mailing them.  This appears to work, but it has one
problem which can be crucial: a newsgroup posting does not contain a
mail path back to the sender.  Thus, if I need to ask for more
information, I may be unable to reach you.  For this reason, it is
better to send bug reports to the mailing list.

As a last resort, send bug reports on paper to:

     GNU Compiler Bugs
     545 Tech Sq
     Cambridge, MA 02139

The fundamental principle of reporting bugs usefully is this: *report
all the facts*.  If you are not sure whether to state a fact or leave
it out, state it!

Often people omit facts because they think they know what causes the
problem and they conclude that some details don't matter.  Thus, you
might assume that the name of the variable you use in an example does
not matter.  Well, probably it doesn't, but one cannot be sure. 
Perhaps the bug is a stray memory reference which happens to fetch
from the location where that name is stored in memory; perhaps, if
the name were different, the contents of that location would fool the
compiler into doing the right thing despite the bug.  Play it safe
and give a specific, complete example.  That is the easiest thing for
you to do, and the most helpful.

Keep in mind that the purpose of a bug report is to enable me to fix
the bug if it is not known.  It isn't very important what happens if
the bug is already known.  Therefore, always write your bug reports
on the assumption that the bug is not known.

Sometimes people give a few sketchy facts and ask, "Does this ring a
bell?"  Those bug reports are useless, and I urge everyone to *refuse
to respond to them* except to chide the sender to report bugs properly.

To enable me to fix the bug, you should include all these things:

   * The version of GNU CC.  You can get this by running it with the
     `-v' option.

     Without this, I won't know whether there is any point in looking
     for the bug in the current version of GNU CC.

   * A complete input file that will reproduce the bug.  If the bug
     is in the C preprocessor, send me a source file and any header
     files that it requires.  If the bug is in the compiler proper
     (`cc1'), run your source file through the C preprocessor by
     doing `gcc -E SOURCEFILE > OUTFILE', then include the contents
     of OUTFILE in the bug report.  (Any `-I', `-D' or `-U' options
     that you used in actual compilation should also be used when
     doing this.)

     A single statement is not enough of an example.  In order to
     compile it, it must be embedded in a function definition; and
     the bug might depend on the details of how this is done.

     Without a real example I can compile, all I can do about your
     bug report is wish you luck.  It would be futile to try to guess
     how to provoke the bug.  For example, bugs in register
     allocation and reloading frequently depend on every little
     detail of the function they happen in.

   * The command arguments you gave GNU CC to compile that example
     and observe the bug.  For example, did you use `-O'?  To
     guarantee you won't omit something important, list them all.

     If I were to try to guess the arguments, I would probably guess
     wrong and then I would not encounter the bug.

   * The names of the files that you used for `tm.h' and `md' when
     you installed the compiler.

   * The type of machine you are using, and the operating system name
     and version number.

   * A description of what behavior you observe that you believe is
     incorrect.  For example, "It gets a fatal signal," or, "There is
     an incorrect assembler instruction in the output."

     Of course, if the bug is that the compiler gets a fatal signal,
     then I will certainly notice it.  But if the bug is incorrect
     output, I might not notice unless it is glaringly wrong.  I
     won't study all the assembler code from a 50-line C program just
     on the off chance that it might be wrong.

     Even if the problem you experience is a fatal signal, you should
     still say so explicitly.  Suppose something strange is going on,
     such as, your copy of the compiler is out of synch, or you have
     encountered a bug in the C library on your system.  (This has
     happened!)  Your copy might crash and mine would not.  If you
     told me to expect a crash, then when mine fails to crash, I
     would know that the bug was not happening for me.  If you had
     not told me to expect a crash, then I would not be able to draw
     any conclusion from my observations.

     Often the observed symptom is incorrect output when your program
     is run.  Sad to say, this is not enough information for me
     unless the program is short and simple.  If you send me a large
     program, I don't have time to figure out how it would work if
     compiled correctly, much less which line of it was compiled
     wrong.  So you will have to do that.  Tell me which source line
     it is, and what incorrect result happens when that line is
     executed.  A person who understands the test program can find
     this as easily as a bug in the program itself.

   * If you send me examples of output from GNU CC, please use `-g'
     when you make them.  The debugging information includes source
     line numbers which are essential for correlating the output with
     the input.

   * If you wish to suggest changes to the GNU CC source, send me
     context diffs.  If you even discuss something in the GNU CC
     source, refer to it by context, not by line number.

     The line numbers in my development sources don't match those in
     your sources.  Your line numbers would convey no useful
     information to me.

   * Additional information from a debugger might enable me to find a
     problem on a machine which I do not have available myself. 
     However, you need to think when you collect this information if
     you want it to have any chance of being useful.

     For example, many people send just a backtrace, but that is
     never useful by itself.  A simple backtrace with arguments
     conveys little about GNU CC because the compiler is largely
     data-driven; the same functions are called over and over for
     different RTL insns, doing different things depending on the
     details of the insn.

     Most of the arguments listed in the backtrace are useless
     because they are pointers to RTL list structure.  The numeric
     values of the pointers, which the debugger prints in the
     backtrace, have no significance whatever; all that matters is
     the contents of the objects they point to (and most of the
     contents are other such pointers).

     In addition, most compiler passes consist of one or more loops
     that scan the RTL insn sequence.  The most vital piece of
     information about such a loop--which insn it has reached--is
     usually in a local variable, not in an argument.

     What you need to provide in addition to a backtrace are the
     values of the local variables for several stack frames up.  When
     a local variable or an argument is an RTX, first print its value
     and then use the GDB command `pr' to print the RTL expression
     that it points to.  (If GDB doesn't run on your machine, use
     your debugger to call the function `debug_rtx' with the RTX as
     an argument.)  In general, whenever a variable is a pointer, its
     value is no use without the data it points to.

     In addition, include a debugging dump from just before the pass
     in which the crash happens.  Most bugs involve a series of
     insns, not just one.

Here are some things that are not necessary:

   * A description of the envelope of the bug.

     Often people who encounter a bug spend a lot of time
     investigating which changes to the input file will make the bug
     go away and which changes will not affect it.

     This is often time consuming and not very useful, because the
     way I will find the bug is by running a single example under the
     debugger with breakpoints, not by pure deduction from a series
     of examples.  I recommend that you save your time for something
     else.

     Of course, if you can find a simpler example to report *instead*
     of the original one, that is a convenience for me.  Errors in
     the output will be easier to spot, running under the debugger
     will take less time, etc.  Most GNU CC bugs involve just one
     function, so the most straightforward way to simplify an example
     is to delete all the function definitions except the one where
     the bug occurs.  Those earlier in the file may be replaced by
     external declarations if the crucial function depends on them. 
     (Exception: inline functions may affect compilation of functions
     defined later in the file.)

     However, simplification is not vital; if you don't want to do
     this, report the bug anyway and send me the entire test case you
     used.

   * A patch for the bug.

     A patch for the bug does help me if it is a good one.  But don't
     omit the necessary information, such as the test case, on the
     assumption that a patch is all I need.  I might see problems
     with your patch and decide to fix the problem another way, or I
     might not understand it at all.

     Sometimes with a program as complicated as GNU CC it is very
     hard to construct an example that will make the program follow a
     certain path through the code.  If you don't send me the
     example, I won't be able to construct one, so I won't be able to
     verify that the bug is fixed.

     And if I can't understand what bug you are trying to fix, or why
     your patch should be an improvement, I won't install it.  A test
     case will help me to understand.

   * A guess about what the bug is or what it depends on.

     Such guesses are usually wrong.  Even I can't guess right about
     such things without first using the debugger to find the facts.



File: gcc.info,  Node: Portability,  Next: Interface,  Prev: Bugs,  Up: Top

GNU CC and Portability
**********************

The main goal of GNU CC was to make a good, fast compiler for
machines in the class that the GNU system aims to run on: 32-bit
machines that address 8-bit bytes and have several general registers.
Elegance, theoretical power and simplicity are only secondary.

GNU CC gets most of the information about the target machine from a
machine description which gives an algebraic formula for each of the
machine's instructions.  This is a very clean way to describe the
target.  But when the compiler needs information that is difficult to
express in this fashion, I have not hesitated to define an ad-hoc
parameter to the machine description.  The purpose of portability is
to reduce the total work needed on the compiler; it was not of
interest for its own sake.

GNU CC does not contain machine dependent code, but it does contain
code that depends on machine parameters such as endianness (whether
the most significant byte has the highest or lowest address of the
bytes in a word) and the availability of autoincrement addressing. 
In the RTL-generation pass, it is often necessary to have multiple
strategies for generating code for a particular kind of syntax tree,
strategies that are usable for different combinations of parameters. 
Often I have not tried to address all possible cases, but only the
common ones or only the ones that I have encountered.  As a result, a
new target may require additional strategies.  You will know if this
happens because the compiler will call `abort'.  Fortunately, the new
strategies can be added in a machine-independent fashion, and will
affect only the target machines that need them.


