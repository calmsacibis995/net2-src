Info file gcc.info, produced by Makeinfo, -*- Text -*- from input
file gcc.texinfo.

This file documents the use and the internals of the GNU compiler.

Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License" and "Protect
Your Freedom--Fight `Look And Feel'" are included exactly as in the
original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License" and "Protect Your Freedom--Fight `Look And Feel'" and this
permission notice may be included in translations approved by the
Free Software Foundation instead of in the original English.



File: gcc.info,  Node: Cross-compilation,  Next: Misc,  Prev: Condition Code,  Up: Machine Macros

Cross Compilation and Floating-Point Format
===========================================

While all modern machines use 2's complement representation for
integers, there are a variety of representations for floating point
numbers.  This means that in a cross-compiler the representation of
floating point numbers in the compiled program may be different from
that used in the machine doing the compilation.

Because different representation systems may offer different amounts
of range and precision, the cross compiler cannot safely use the host
machine's floating point arithmetic.  Therefore, floating point
constants must be represented in the target machine's format.  This
means that the cross compiler cannot use `atof' to parse a floating
point constant; it must have its own special routine to use instead. 
Also, constant folding must emulate the target machine's arithmetic
(or must not be done at all).

The macros in the following table should be defined only if you are
cross compiling between different floating point formats.

Otherwise, don't define them. Then default definitions will be set up
which use `double' as the data type, `==' to test for equality, etc.

You don't need to worry about how many times you use an operand of
any of these macros.  The compiler never uses operands which have
side effects.

`REAL_VALUE_TYPE'
     A macro for the C data type to be used to hold a floating point
     value in the target machine's format.  Typically this would be a
     `struct' containing an array of `int'.

`REAL_VALUES_EQUAL (X, Y)'
     A macro for a C expression which compares for equality the two
     values, X and Y, both of type `REAL_VALUE_TYPE'.

`REAL_VALUES_LESS (X, Y)'
     A macro for a C expression which tests whether X is less than Y,
     both values being of type `REAL_VALUE_TYPE' and interpreted as
     floating point numbers in the target machine's representation.

`REAL_VALUE_LDEXP (X, SCALE)'
     A macro for a C expression which performs the standard library
     function `ldexp', but using the target machine's floating point
     representation.  Both X and the value of the expression have
     type `REAL_VALUE_TYPE'.  The second argument, SCALE, is an
     integer.

`REAL_VALUE_ATOF (STRING)'
     A macro for a C expression which converts STRING, an expression
     of type `char *', into a floating point number in the target
     machine's representation.  The value has type `REAL_VALUE_TYPE'.

Define the following additional macros if you want to make floating
point constant folding work while cross compiling.  If you don't
define them, cross compilation is still possible, but constant
folding will not happen for floating point values.

`REAL_ARITHMETIC (OUTPUT, CODE, X, Y)'
     A macro for a C statement which calculates an arithmetic
     operation of the two floating point values X and Y, both of type
     `REAL_VALUE_TYPE' in the target machine's representation, to
     produce a result of the same type and representation which is
     stored in OUTPUT (which will be a variable).

     The operation to be performed is specified by CODE, a tree code
     which will always be one of the following: `PLUS_EXPR',
     `MINUS_EXPR', `MULT_EXPR', `RDIV_EXPR', `MAX_EXPR', `MIN_EXPR'.

     The expansion of this macro is responsible for checking for
     overflow.  If overflow happens, the macro expansion should
     execute the statement `return 0;', which indicates the inability
     to perform the arithmetic operation requested.

`REAL_VALUE_NEGATE (X)'
     A macro for a C expression which returns the negative of the
     floating point value X.  Both X and the value of the expression
     have type `REAL_VALUE_TYPE' and are in the target machine's
     floating point representation.

     There is no way for this macro to report overflow, since
     overflow can't happen in the negation operation.

`REAL_VALUE_TO_INT (LOW, HIGH, X)'
     A macro for a C expression which converts a floating point value
     X into a double-precision integer which is then stored into LOW
     and HIGH, two variables of type INT.

`REAL_VALUE_FROM_INT (X, LOW, HIGH)'
     A macro for a C expression which converts a double-precision
     integer found in LOW and HIGH, two variables of type INT, into a
     floating point value which is then stored into X.



File: gcc.info,  Node: Misc,  Next: Assembler Format,  Prev: Cross-compilation,  Up: Machine Macros

Miscellaneous Parameters
========================

`CASE_VECTOR_MODE'
     An alias for a machine mode name.  This is the machine mode that
     elements of a jump-table should have.

`CASE_VECTOR_PC_RELATIVE'
     Define this macro if jump-tables should contain relative
     addresses.

`CASE_DROPS_THROUGH'
     Define this if control falls through a `case' insn when the
     index value is out of range.  This means the specified
     default-label is actually ignored by the `case' insn proper.

`IMPLICIT_FIX_EXPR'
     An alias for a tree code that should be used by default for
     conversion of floating point values to fixed point.  Normally,
     `FIX_ROUND_EXPR' is used.

`FIXUNS_TRUNC_LIKE_FIX_TRUNC'
     Define this macro if the same instructions that convert a
     floating point number to a signed fixed point number also
     convert validly to an unsigned one.

`EASY_DIV_EXPR'
     An alias for a tree code that is the easiest kind of division to
     compile code for in the general case.  It may be
     `TRUNC_DIV_EXPR', `FLOOR_DIV_EXPR', `CEIL_DIV_EXPR' or
     `ROUND_DIV_EXPR'.  These four division operators differ in how
     they round the result to an integer.  `EASY_DIV_EXPR' is used
     when it is permissible to use any of those kinds of division and
     the choice should be made on the basis of efficiency.

`DEFAULT_SIGNED_CHAR'
     An expression whose value is 1 or 0, according to whether the
     type `char' should be signed or unsigned by default.  The user
     can always override this default with the options
     `-fsigned-char' and `-funsigned-char'.

`SCCS_DIRECTIVE'
     Define this if the preprocessor should ignore `#sccs' directives
     and print no error message.

`HAVE_VPRINTF'
     Define this if the library function `vprintf' is available on
     your system.

`MOVE_MAX'
     The maximum number of bytes that a single instruction can move
     quickly from memory to memory.

`INT_TYPE_SIZE'
     A C expression for the size in bits of the type `int' on the
     target machine.  If you don't define this, the default is one
     word.

`SHORT_TYPE_SIZE'
     A C expression for the size in bits of the type `short' on the
     target machine.  If you don't define this, the default is half a
     word.  (If this would be less than one storage unit, it is
     rounded up to one unit.)

`LONG_TYPE_SIZE'
     A C expression for the size in bits of the type `long' on the
     target machine.  If you don't define this, the default is one
     word.

`LONG_LONG_TYPE_SIZE'
     A C expression for the size in bits of the type `long long' on
     the target machine.  If you don't define this, the default is
     two words.

`CHAR_TYPE_SIZE'
     A C expression for the size in bits of the type `char' on the
     target machine.  If you don't define this, the default is one
     quarter of a word.  (If this would be less than one storage
     unit, it is rounded up to one unit.)

`FLOAT_TYPE_SIZE'
     A C expression for the size in bits of the type `float' on the
     target machine.  If you don't define this, the default is one
     word.

`DOUBLE_TYPE_SIZE'
     A C expression for the size in bits of the type `double' on the
     target machine.  If you don't define this, the default is two
     words.

`LONG_DOUBLE_TYPE_SIZE'
     A C expression for the size in bits of the type `long double' on
     the target machine.  If you don't define this, the default is
     two words.

`SLOW_BYTE_ACCESS'
     Define this macro as a C expression which is nonzero if
     accessing less than a word of memory (i.e. a `char' or a
     `short') is slow (requires more than one instruction).

`SLOW_ZERO_EXTEND'
     Define this macro if zero-extension (of a `char' or `short' to
     an `int') can be done faster if the destination is a register
     that is known to be zero.

     If you define this macro, you must have instruction patterns
     that recognize RTL structures like this:

          (set (strict-low-part (subreg:QI (reg:SI ...) 0)) ...)

     and likewise for `HImode'.

`SHIFT_COUNT_TRUNCATED'
     Define this macro if shift instructions ignore all but the
     lowest few bits of the shift count.  It implies that a
     sign-extend or zero-extend instruction for the shift count can
     be omitted.

`TRULY_NOOP_TRUNCATION (OUTPREC, INPREC)'
     A C expression which is nonzero if on this machine it is safe to
     "convert" an integer of INPREC bits to one of OUTPREC bits
     (where OUTPREC is smaller than INPREC) by merely operating on it
     as if it had only OUTPREC bits.

     On many machines, this expression can be 1.

`NO_FUNCTION_CSE'
     Define this macro if it is as good or better to call a constant
     function address than to call an address kept in a register.

`PROMOTE_PROTOTYPES'
     Define this macro if an argument declared as `char' or `short'
     in a prototype should actually be passed as an `int'.  In
     addition to avoiding errors in certain cases of mismatch, it
     also makes for better code on certain machines.

`STORE_FLAG_VALUE'
     A C expression for the value stored by a store-flag instruction
     (`sCOND') when the condition is true.  This is usually 1 or -1;
     it is required to be an odd number or a negative number.

     Do not define `STORE_FLAG_VALUE' if the machine has no
     store-flag instructions.

`Pmode'
     An alias for the machine mode for pointers.  Normally the
     definition can be

          #define Pmode SImode

`FUNCTION_MODE'
     An alias for the machine mode used for memory references to
     functions being called, in `call' RTL expressions.  On most
     machines this should be `QImode'.

`INSN_MACHINE_INFO'
     This macro should expand into a C structure type to use for the
     machine-dependent info field specified with the optional last
     argument in `define_insn' and `define_peephole' patterns.  For
     example, it might expand into `struct machine_info'; then it
     would be up to you to define this structure in the `tm.h' file.

     You do not need to define this macro if you do not write the
     optional last argument in any of the patterns in the machine
     description.

`DEFAULT_MACHINE_INFO'
     This macro should expand into a C initializer to use to
     initialize the machine-dependent info for one insn pattern.  It
     is used for patterns that do not specify the machine-dependent
     info.

     If you do not define this macro, zero is used.

`CONST_COSTS (X, CODE)'
     A part of a C `switch' statement that describes the relative
     costs of constant RTL expressions.  It must contain `case'
     labels for expression codes `const_int', `const', `symbol_ref',
     `label_ref' and `const_double'.  Each case must ultimately reach
     a `return' statement to return the relative cost of the use of
     that kind of constant value in an expression.  The cost may
     depend on the precise value of the constant, which is available
     for examination in X.

     CODE is the expression code--redundant, since it can be obtained
     with `GET_CODE (X)'.

`DOLLARS_IN_IDENTIFIERS'
     Define this to be nonzero if the character `$' should be allowed
     by default in identifier names.



File: gcc.info,  Node: Assembler Format,  Prev: Misc,  Up: Machine Macros

Output of Assembler Code
========================

`ASM_SPEC'
     A C string constant that tells the GNU CC driver program options
     to pass to the assembler.  It can also specify how to translate
     options you give to GNU CC into options for GNU CC to pass to
     the assembler.  See the file `tm-sun3.h' for an example of this.

     Do not define this macro if it does not need to do anything.

`LINK_SPEC'
     A C string constant that tells the GNU CC driver program options
     to pass to the linker.  It can also specify how to translate
     options you give to GNU CC into options for GNU CC to pass to
     the linker.

     Do not define this macro if it does not need to do anything.

`LIB_SPEC'
     Another C string constant used much like `LINK_SPEC'.  The
     difference between the two is that `LIBS_SPEC' is used at the
     end of the command given to the linker.

     If this macro is not defined, a default is provided that loads
     the standard C library from the usual place.  See `gcc.c'.

`STARTFILE_SPEC'
     Another C string constant used much like `LINK_SPEC'.  The
     difference between the two is that `STARTFILE_SPEC' is used at
     the very beginning of the command given to the linker.

     If this macro is not defined, a default is provided that loads
     the standard C startup file from the usual place.  See `gcc.c'.

`STANDARD_EXEC_PREFIX'
     Define this macro as a C string constant if you wish to override
     the standard choice of `/usr/local/lib/gcc-' as the default
     prefix to try when searching for the executable files of the
     compiler.

     The prefix specified by the `-B' option, if any, is tried before
     the default prefix.  After the default prefix, if the executable
     is not found that way, `/usr/lib/gcc-' is tried next; then the
     directories in your search path for shell commands are searched.

`STANDARD_STARTFILE_PREFIX'
     Define this macro as a C string constant if you wish to override
     the standard choice of `/usr/local/lib/' as the default prefix
     to try when searching for startup files such as `crt0.o'.

     In this search, all the prefixes tried for executable files are
     tried first.  Then comes the default startfile prefix specified
     by this macro, followed by the prefixes `/lib/' and `/usr/lib/'
     as last resorts.

`ASM_FILE_START (STREAM)'
     A C expression which outputs to the stdio stream STREAM some
     appropriate text to go at the start of an assembler file.

     Normally this macro is defined to output a line containing
     `#NO_APP', which is a comment that has no effect on most
     assemblers but tells the GNU assembler that it can save time by
     not checking for certain assembler constructs.

     On systems that use SDB, it is necessary to output certain
     commands; see `tm-attasm.h'.

`ASM_FILE_END (STREAM)'
     A C expression which outputs to the stdio stream STREAM some
     appropriate text to go at the end of an assembler file.

     If this macro is not defined, the default is to output nothing
     special at the end of the file.  Most systems don't require any
     definition.

     On systems that use SDB, it is necessary to output certain
     commands; see `tm-attasm.h'.

`ASM_IDENTIFY_GCC (FILE)'
     A C statement to output assembler commands which will identify
     the object file as having been compiled with GNU CC (or another
     GNU compiler).

     If you don't define this macro, the string `gcc_compiled.:' is
     output.  This string is calculated to define a symbol which, on
     BSD systems, will never be defined for any other reason.  GDB
     checks for the presence of this symbol when reading the symbol
     table of an executable.

     On non-BSD systems, you must arrange communication with GDB in
     some other fashion.  If GDB is not used on your system, you can
     define this macro with an empty body.

`ASM_APP_ON'
     A C string constant for text to be output before each `asm'
     statement or group of consecutive ones.  Normally this is
     `"#APP"', which is a comment that has no effect on most
     assemblers but tells the GNU assembler that it must check the
     lines that follow for all valid assembler constructs.

`ASM_APP_OFF'
     A C string constant for text to be output after each `asm'
     statement or group of consecutive ones.  Normally this is
     `"#NO_APP"', which tells the GNU assembler to resume making the
     time-saving assumptions that are valid for ordinary compiler
     output.

`TEXT_SECTION_ASM_OP'
     A C string constant for the assembler operation that should
     precede instructions and read-only data.  Normally `".text"' is
     right.

`DATA_SECTION_ASM_OP'
     A C string constant for the assembler operation to identify the
     following data as writable initialized data.  Normally `".data"'
     is right.

`EXTRA_SECTIONS'
     A list of names for sections other than the standard two, which
     are `in_text' and `in_data'.  You need not define this macro on
     a system with no other sections (that GCC needs to use).

`EXTRA_SECTION_FUNCTIONS'
     One or more functions to be defined in `varasm.c'.  These
     functions should do jobs analogous to those of `text_section'
     and `data_section', for your additional sections.  Do not define
     this macro if you do not define `EXTRA_SECTIONS'.

`SELECT_SECTION (EXP)'
     A C statement or statements to switch to the appropriate section
     for output of EXP.  You can assume that EXP is either a
     `VAR_DECL' node or a constant of some sort.  Select the section
     by calling `text_section' or one of the alternatives for other
     sections.

     Do not define this macro if you use only the standard two
     sections and put all read-only variables and constants in the
     text section.

`SELECT_RTX_SECTION (MODE, RTX)'
     A C statement or statements to switch to the appropriate section
     for output of RTX in mode MODE.  You can assume that RTX is some
     kind of constant in RTL.  The argument MODE is redundant except
     in the case of a `const_int' rtx.  Select the section by calling
     `text_section' or one of the alternatives for other sections.

     Do not define this macro if you use only the standard two
     sections and put all constants in the text section.

`REGISTER_NAMES'
     A C initializer containing the assembler's names for the machine
     registers, each one as a C string constant.  This is what
     translates register numbers in the compiler into assembler
     language.

`DBX_REGISTER_NUMBER (REGNO)'
     A C expression that returns the DBX register number for the
     compiler register number REGNO.  In simple cases, the value of
     this expression may be REGNO itself.  But sometimes there are
     some registers that the compiler knows about and DBX does not,
     or vice versa.  In such cases, some register may need to have
     one number in the compiler and another for DBX.

`DBX_DEBUGGING_INFO'
     Define this macro if GNU CC should produce debugging output for
     DBX in response to the `-g' option.

`SDB_DEBUGGING_INFO'
     Define this macro if GNU CC should produce debugging output for
     SDB in response to the `-g' option.

`PUT_SDB_OP'
     Define these macros to override the assembler syntax for the
     special SDB assembler directives.  See `sdbout.c' for a list of
     these macros and their arguments.  If the standard syntax is
     used, you need not define them yourself.

`SDB_GENERATE_FAKE'
     Define this macro to override the usual method of constructing a
     dummy name for anonymous structure and union types.  See
     `sdbout.c' for more information.

`DBX_NO_XREFS'
     Define this macro if DBX on your system does not support the
     construct `xsTAGNAME'.  On some systems, this construct is used
     to describe a forward reference to a structure named TAGNAME. 
     On other systems, this construct is not supported at all.

`DBX_CONTIN_LENGTH'
     A symbol name in DBX-format debugging information is normally
     continued (split into two separate `.stabs' directives) when it
     exceeds a certain length (by default, 80 characters).  On some
     operating systems, DBX requires this splitting; on others,
     splitting must not be done.  You can inhibit splitting by
     defining this macro with the value zero.  You can override the
     default splitting-length by defining this macro as an expression
     for the length you desire.

`DBX_CONTIN_CHAR'
     Normally continuation is indicated by adding a `\' character to
     the end of a `.stabs' string when a continuation follows.  To
     use a different character instead, define this macro as a
     character constant for the character you want to use.  Do not
     define this macro if backslash is correct for your system.

`DBX_STATIC_STAB_DATA_SECTION'
     Define this macro if it is necessary to go to the data section
     before outputting the `.stabs' pseudo-op for a non-global static
     variable.

`ASM_OUTPUT_LABEL (STREAM, NAME)'
     A C statement (sans semicolon) to output to the stdio stream
     STREAM the assembler definition of a label named NAME.  Use the
     expression `assemble_name (STREAM, NAME)' to output the name
     itself; before and after that, output the additional assembler
     syntax for defining the name, and a newline.

`ASM_DECLARE_FUNCTION_NAME (STREAM, NAME, DECL)'
     A C statement (sans semicolon) to output to the stdio stream
     STREAM any text necessary for declaring the name NAME of a
     function which is being defined.  This macro is responsible for
     outputting the label definition (perhaps using
     `ASM_OUTPUT_LABEL').  The argument DECL is the `FUNCTION_DECL'
     tree node representing the function.

     If this macro is not defined, then the function name is defined
     in the usual manner as a label (by means of `ASM_OUTPUT_LABEL').

`ASM_GLOBALIZE_LABEL (STREAM, NAME)'
     A C statement (sans semicolon) to output to the stdio stream
     STREAM some commands that will make the label NAME global; that
     is, available for reference from other files.  Use the
     expression `assemble_name (STREAM, NAME)' to output the name
     itself; before and after that, output the additional assembler
     syntax for making that name global, and a newline.

`ASM_OUTPUT_EXTERNAL (STREAM, DECL, NAME)'
     A C statement (sans semicolon) to output to the stdio stream
     STREAM any text necessary for declaring the name of an external
     symbol named NAME which is referenced in this compilation but
     not defined.  The value of DECL is the tree node for the
     declaration.

     This macro need not be defined if it does not need to output
     anything.  The GNU assembler and most Unix assemblers don't
     require anything.

`ASM_OUTPUT_LABELREF (STREAM, NAME)'
     A C statement to output to the stdio stream STREAM a reference
     in assembler syntax to a label named NAME.  The character `_'
     should be added to the front of the name, if that is customary
     on your operating system, as it is in most Berkeley Unix
     systems.  This macro is used in `assemble_name'.

`ASM_GENERATE_INTERNAL_LABEL (STRING, PREFIX, NUM)'
     A C statement to store into the string STRING a label whose name
     is made from the string PREFIX and the number NUM.

     This string, when output subsequently by `ASM_OUTPUT_LABELREF',
     should produce the same output that `ASM_OUTPUT_INTERNAL_LABEL'
     would produce with the same PREFIX and NUM.

`ASM_OUTPUT_INTERNAL_LABEL (STREAM, PREFIX, NUM)'
     A C statement to output to the stdio stream STREAM a label whose
     name is made from the string PREFIX and the number NUM.  These
     labels are used for internal purposes, and there is no reason
     for them to appear in the symbol table of the object file.  On
     many systems, the letter `L' at the beginning of a label has
     this effect.  The usual definition of this macro is as follows:

          fprintf (STREAM, "L%s%d:\n", PREFIX, NUM)

`ASM_OUTPUT_CASE_LABEL (STREAM, PREFIX, NUM, TABLE)'
     Define this if the label before a jump-table needs to be output
     specially.  The first three arguments are the same as for
     `ASM_OUTPUT_INTERNAL_LABEL'; the fourth argument is the
     jump-table which follows (a `jump_insn' containing an `addr_vec'
     or `addr_diff_vec').

     This feature is used on system V to output a `swbeg' statement
     for the table.

     If this macro is not defined, these labels are output with
     `ASM_OUTPUT_INTERNAL_LABEL'.

`ASM_OUTPUT_CASE_END (STREAM, NUM, TABLE)'
     Define this if something special must be output at the end of a
     jump-table.  The definition should be a C statement to be
     executed after the assembler code for the table is written.  It
     should write the appropriate code to stdio stream STREAM.  The
     argument TABLE is the jump-table insn, and NUM is the
     label-number of the preceding label.

     If this macro is not defined, nothing special is output at the
     end of the jump-table.

`ASM_OUTPUT_ALIGN_CODE (FILE)'
     A C expression to output text to align the location counter in
     the way that is desirable at a point in the code that is reached
     only by jumping.

     This macro need not be defined if you don't want any special
     alignment to be done at such a time.  Most machine descriptions
     do not currently define the macro.

`ASM_FORMAT_PRIVATE_NAME (OUTVAR, NAME, NUMBER)'
     A C expression to assign to OUTVAR (which is a variable of type
     `char *') a newly allocated string made from the string NAME and
     the number NUMBER, with some suitable punctuation added.  Use
     `alloca' to get space for the string.

     This string will be used as the argument to
     `ASM_OUTPUT_LABELREF' to produce an assembler label for an
     internal static variable whose name is NAME.  Therefore, the
     string must be such as to result in valid assembler code.  The
     argument NUMBER is different each time this macro is executed;
     it prevents conflicts between similarly-named internal static
     variables in different scopes.

     Ideally this string should not be a valid C identifier, to
     prevent any conflict with the user's own symbols.  Most
     assemblers allow periods or percent signs in assembler symbols;
     putting at least one of these between the name and the number
     will suffice.

`ASM_OUTPUT_REG_PUSH (STREAM, REGNO)'
     A C expression to output to STREAM some assembler code which
     will push hard register number REGNO onto the stack.  The code
     need not be optimal, since this macro is used only when profiling.

`ASM_OUTPUT_REG_POP (STREAM, REGNO)'
     A C expression to output to STREAM some assembler code which
     will pop hard register number REGNO off of the stack.  The code
     need not be optimal, since this macro is used only when profiling.

`ASM_OUTPUT_ADDR_DIFF_ELT (STREAM, VALUE, REL)'
     This macro should be provided on machines where the addresses in
     a dispatch table are relative to the table's own address.

     The definition should be a C statement to output to the stdio
     stream STREAM an assembler pseudo-instruction to generate a
     difference between two labels.  VALUE and REL are the numbers of
     two internal labels.  The definitions of these labels are output
     using `ASM_OUTPUT_INTERNAL_LABEL', and they must be printed in
     the same way here.  For example,

          fprintf (STREAM, "\t.word L%d-L%d\n",
                   VALUE, REL)

`ASM_OUTPUT_ADDR_VEC_ELT (STREAM, VALUE)'
     This macro should be provided on machines where the addresses in
     a dispatch table are absolute.

     The definition should be a C statement to output to the stdio
     stream STREAM an assembler pseudo-instruction to generate a
     reference to a label.  VALUE is the number of an internal label
     whose definition is output using `ASM_OUTPUT_INTERNAL_LABEL'. 
     For example,

          fprintf (STREAM, "\t.word L%d\n", VALUE)

`ASM_OUTPUT_DOUBLE (STREAM, VALUE)'
     A C statement to output to the stdio stream STREAM an assembler
     instruction to assemble a `double' constant whose value is
     VALUE.  VALUE will be a C expression of type `double'.

`ASM_OUTPUT_FLOAT (STREAM, VALUE)'
     A C statement to output to the stdio stream STREAM an assembler
     instruction to assemble a `float' constant whose value is VALUE.
     vALUE will be a C expression of type `float'.

`ASM_OUTPUT_INT (STREAM, EXP)'
`ASM_OUTPUT_SHORT (STREAM, EXP)'
`ASM_OUTPUT_CHAR (STREAM, EXP)'
     A C statement to output to the stdio stream STREAM an assembler
     instruction to assemble a `int', `short' or `char' constant
     whose value is VALUE.  The argument EXP will be an RTL
     expression which represents a constant value.  Use
     `output_addr_const (STREAM, EXP)' to output this value as an
     assembler expression.

`ASM_OUTPUT_DOUBLE_INT (STREAM, EXP)'
     A C statement to output to the stdio stream STREAM an assembler
     instruction to assemble a `long long' constant whose value is
     EXP.  The argument EXP will be an RTL expression which
     represents a constant value.  It may be a `const_double' RTX, or
     it may be an ordinary single-precision constant.  In the latter
     case, you should zero-extend it.

`ASM_OUTPUT_BYTE (STREAM, VALUE)'
     A C statement to output to the stdio stream STREAM an assembler
     instruction to assemble a single byte containing the number VALUE.

`ASM_OUTPUT_ASCII (STREAM, PTR, LEN)'
     A C statement to output to the stdio stream STREAM an assembler
     instruction to assemble a string constant containing the LEN
     bytes at PTR.  PTR will be a C expression of type `char *' and
     LEN a C expression of type `int'.

     If the assembler has a `.ascii' pseudo-op as found in the
     Berkeley Unix assembler, do not define the macro
     `ASM_OUTPUT_ASCII'.

`ASM_OUTPUT_SKIP (STREAM, NBYTES)'
     A C statement to output to the stdio stream STREAM an assembler
     instruction to advance the location counter by NBYTES bytes. 
     NBYTES will be a C expression of type `int'.

`ASM_OUTPUT_ALIGN (STREAM, POWER)'
     A C statement to output to the stdio stream STREAM an assembler
     instruction to advance the location counter to a multiple of 2
     to the POWER bytes.  POWER will be a C expression of type `int'.

`ASM_OUTPUT_COMMON (STREAM, NAME, SIZE, ROUNDED)'
     A C statement (sans semicolon) to output to the stdio stream
     STREAM the assembler definition of a common-label named NAME
     whose size is SIZE bytes.  The variable ROUNDED is the size
     rounded up to whatever alignment the caller wants.

     Use the expression `assemble_name (STREAM, NAME)' to output the
     name itself; before and after that, output the additional
     assembler syntax for defining the name, and a newline.

     This macro controls how the assembler definitions of
     uninitialized global variables are output.

`ASM_OUTPUT_LOCAL (STREAM, NAME, SIZE, ROUNDED)'
     A C statement (sans semicolon) to output to the stdio stream
     STREAM the assembler definition of a local-common-label named
     NAME whose size is SIZE bytes.  The variable ROUNDED is the size
     rounded up to whatever alignment the caller wants.

     Use the expression `assemble_name (STREAM, NAME)' to output the
     name itself; before and after that, output the additional
     assembler syntax for defining the name, and a newline.

     This macro controls how the assembler definitions of
     uninitialized static variables are output.

`ASM_OUTPUT_SOURCE_FILENAME (STREAM, NAME)'
     A C statment to output DBX or SDB debugging information which
     indicates that filename NAME is the current source file to the
     stdio stream STREAM.

     This macro need not be defined if the standard form of debugging
     information for the debugger in use is appropriate.

`ASM_OUTPUT_SOURCE_LINE (STREAM, LINE)'
     A C statment to output DBX or SDB debugging information before
     code for line number LINE of the current source file to the
     stdio stream STREAM.

     This macro need not be defined if the standard form of debugging
     information for the debugger in use is appropriate.

`ASM_OUTPUT_IDENT (STREAM, STRING)'
     A C statement to output something to the assembler file to
     handle a `#ident' directive containing the text STRING.  If this
     macro is not defined, nothing is output for a `#ident' directive.

`TARGET_BELL'
     A C constant expression for the integer value for escape
     sequence `\a'.

`TARGET_BS'
`TARGET_TAB'
`TARGET_NEWLINE'
     C constant expressions for the integer values for escape
     sequences `\b', `\t' and `\n'.

`TARGET_VT'
`TARGET_FF'
`TARGET_CR'
     C constant expressions for the integer values for escape
     sequences `\v', `\f' and `\r'.

`ASM_OUTPUT_OPCODE (STREAM, PTR)'
     Define this macro if you are using an unusual assembler that
     requires different names for the machine instructions.

     The definition is a C statement or statements which output an
     assembler instruction opcode to the stdio stream STREAM.  The
     macro-operand PTR is a variable of type `char *' which points to
     the opcode name in its "internal" form--the form that is written
     in the machine description.  The definition should output the
     opcode name to STREAM, performing any translation you desire,
     and increment the variable PTR to point at the end of the opcode
     so that it will not be output twice.

     In fact, your macro definition may process less than the entire
     opcode name, or more than the opcode name; but if you want to
     process text that includes `%'-sequences to substitute operands,
     you must take care of the substitution yourself.  Just be sure
     to increment PTR over whatever text should not be output normally.

     If you need to look at the operand values, they can be found as
     the elements of `recog_operand'.

     If the macro definition does nothing, the instruction is output
     in the usual way.

`FINAL_PRESCAN_INSN (INSN, OPVEC, NOPERANDS)'
     If defined, a C statement to be executed just prior to the
     output of assembler code for INSN, to modify the extracted
     operands so they will be output differently.

     Here the argument OPVEC is the vector containing the operands
     extracted from INSN, and NOPERANDS is the number of elements of
     the vector which contain meaningful data for this insn.  The
     contents of this vector are what will be used to convert the
     insn template into assembler code, so you can change the
     assembler output by changing the contents of the vector.

     This macro is useful when various assembler syntaxes share a
     single file of instruction patterns; by defining this macro
     differently, you can cause a large class of instructions to be
     output differently (such as with rearranged operands). 
     Naturally, variations in assembler syntax affecting individual
     insn patterns ought to be handled by writing conditional output
     routines in those patterns.

     If this macro is not defined, it is equivalent to a null
     statement.

`PRINT_OPERAND (STREAM, X, CODE)'
     A C compound statement to output to stdio stream STREAM the
     assembler syntax for an instruction operand X.  X is an RTL
     expression.

     CODE is a value that can be used to specify one of several ways
     of printing the operand.  It is used when identical operands
     must be printed differently depending on the context.  CODE
     comes from the `%' specification that was used to request
     printing of the operand.  If the specification was just `%DIGIT'
     then CODE is 0; if the specification was `%LTR DIGIT' then CODE
     is the ASCII code for LTR.

     If X is a register, this macro should print the register's name.
     The names can be found in an array `reg_names' whose type is
     `char *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.

     When the machine description has a specification `%PUNCT' (a `%'
     followed by a punctuation character), this macro is called with
     a null pointer for X and the punctuation character for CODE.

`PRINT_OPERAND_PUNCT_VALID_P (CODE)'
     A C expression which evaluates to true if CODE is a valid
     punctuation character for use in the `PRINT_OPERAND' macro.  If
     `PRINT_OPERAND_PUNCT_VALID_P' is not defined, it means that no
     punctuation characters (except for the standard one, `%') are
     used in this way.

`PRINT_OPERAND_ADDRESS (STREAM, X)'
     A C compound statement to output to stdio stream STREAM the
     assembler syntax for an instruction operand that is a memory
     reference whose address is X.  X is an RTL expression.

`ASM_OPEN_PAREN'
`ASM_CLOSE_PAREN'
     These macros are defined as C string constant, describing the
     syntax in the assembler for grouping arithmetic expressions. 
     The following definitions are correct for most assemblers:

          #define ASM_OPEN_PAREN "("
          #define ASM_CLOSE_PAREN ")"



File: gcc.info,  Node: Config,  Prev: Machine Macros,  Up: Top

The Configuration File
**********************

The configuration file `xm-MACHINE.h' contains macro definitions that
describe the machine and system on which the compiler is running. 
Most of the values in it are actually the same on all machines that
GNU CC runs on, so large parts of all configuration files are
identical.  But there are some macros that vary:

`FAILURE_EXIT_CODE'
     A C expression for the status code to be returned when the
     compiler exits after serious errors.

`SUCCESS_EXIT_CODE'
     A C expression for the status code to be returned when the
     compiler exits without serious errors.

`USE_C_ALLOCA'
     Define this macro to indicate that the compiler is running with
     the `alloca' implemented in C.  This version of `alloca' can be
     found in the file `alloca.c'; to use it, you must also alter the
     `Makefile' variable `ALLOCA'.

     This macro, unlike most, describes the machine that the compiler
     is running on, rather than the one the compiler is compiling for.
     Therefore, it should be set in the `xm-MACHINE.h' file rather
     than in the `tm-MACHINE.h' file.

     If you do define this macro, you should probably do it as follows:

          #ifndef __GNUC__
          #define USE_C_ALLOCA
          #else
          #define alloca __builtin_alloca
          #endif

     so that when the compiler is compiled with GNU CC it uses the
     more efficient built-in `alloca' function.

In addition, configuration files for system V define `bcopy', `bzero'
and `bcmp' as aliases.  Some files define `alloca' as a macro when
compiled with GNU CC, in order to take advantage of the benefit of
GNU CC's built-in `alloca'.


